# -*- coding: utf-8 -*-
"""color changing of objects.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HsLQzlFkDmY380DOwp6Ppl_1fM5nIAlq
"""

import torch
import torchvision.transforms as T
from transformers import Mask2FormerImageProcessor, Mask2FormerForUniversalSegmentation
from PIL import Image, ImageFilter
import numpy as np
from typing import List, Tuple, Dict, Union
from skimage import color # For LAB color space manipulation

# --- Determine Device ---
DEVICE = "cuda" if torch.cuda.is_available() else "cpu"
# For color changing, float32 is generally sufficient and avoids half-precision issues
DTYPE = torch.float32
print(f"Using device: {DEVICE} with dtype: {DTYPE}")# --- Determine Device ---

# --- Model Loading ---
# Mask2Former for semantic segmentation
print("Loading Mask2Former model for semantic segmentation...")
processor = Mask2FormerImageProcessor.from_pretrained("facebook/mask2former-swin-large-ade-semantic")
model = Mask2FormerForUniversalSegmentation.from_pretrained("facebook/mask2former-swin-large-ade-semantic")
model = model.to(DEVICE)
print(f"Mask2Former (Semantic Segmentation) loaded to {DEVICE}.")
print("All necessary AI models loaded successfully.")

COLOR_MAPPING_ = {
    '#FFFFFF': 'background', "#787878": "wall", "#B47878": "building;edifice", "#06E6E6": "sky",
    "#503232": "floor;flooring", "#04C803": "tree", "#787850": "ceiling", "#8C8C8C": "road;route",
    "#CC05FF": "bed", "#E6E6E6": "windowpane;window", "#04FA07": "grass", "#E005FF": "cabinet",
    "#EBFF07": "sidewalk;pavement", "#96053D": "person;individual;someone;somebody;mortal;soul",
    "#787846": "earth;ground", "#08FF33": "door;double;door", "#FF0652": "table", "#8FFF8C": "mountain;mount",
    "#CCFF04": "plant;flora;plant;life", "#FF3307": "curtain;drape;drapery;mantle;pall",
    "#CC4603": "chair", "#0066C8": "car;auto;automobile;machine;motorcar", "#3DE6FA": "water",
    "#FF0633": "painting;picture", "#0B66FF": "sofa;couch;lounge", "#FF0747": "shelf",
    "#FF09E0": "house", "#0907E6": "sea", "#DCDCDC": "mirror", "#FF095C": "rug;carpet;carpeting",
    "#7009FF": "field", "#08FFD6": "armchair", "#07FFE0": "seat", "#FFB806": "fence;fencing",
    "#0AFF47": "desk", "#FF290A": "rock;stone", "#07FFFF": "wardrobe;closet;press",
    "#E0FF08": "lamp", "#6608FF": "bathtub;bathing;tub;bath;tub", "#FF3D06": "railing;rail",
    "#FFC207": "cushion", "#FF7A08": "base;pedestal;stand", "#00FF14": "box",
    "#FF0829": "column;pillar", "#FF0599": "signboard;sign", "#0633FF": "chest;of;drawers;chest;bureau;dresser",
    "#EB0CFF": "counter", "#A09614": "sand", "#00A3FF": "sink", "#8C8C8C": "skyscraper",
    "#FA0A0F": "fireplace;hearth;open;fireplace", "#14FF00": "refrigerator;icebox",
    "#1FFF00": "grandstand;covered;stand", "#FF1F00": "path", "#FFE000": "stairs;steps",
    "#99FF00": "runway", "#0000FF": "case;display;case;showcase;vitrine",
    "#FF4700": "pool;table;billiard;table;snooker;table", "#00EBFF": "pillow",
    "#00ADFF": "screen;door;screen", "#1F00FF": "stairway;staircase", "#0BC8C8": "river",
    "#FF5200": "bridge;span", "#00FFF5": "bookcase", "#003DFF": "blind;screen",
    "#00FF70": "coffee;table;cocktail;table", "#00FF85": "toilet;can;commode;crapper;pot;potty;stool;throne",
    "#FF0000": "flower", "#FFA300": "book", "#FF6600": "hill", "#C2FF00": "bench",
    "#008FFF": "countertop", "#33FF00": "stove;kitchen;stove;range;kitchen;range;cooking;stove",
    "#0052FF": "palm;palm;tree", "#00FF29": "kitchen;island",
    "#00FFAD": "computer;computing;machine;computing;device;data;processor;electronic;computer;information;processing;system",
    "#0A00FF": "swivel;chair", "#ADFF00": "boat", "#00FF99": "bar", "#FF5C00": "arcade;machine",
    "#FF00FF": "hovel;hut;hutch;shack;shanty", "#FF00F5": "bus;autobus;coach;charabanc;double-decker;jitney;motorbus;motorcoach;omnibus;passenger;vehicle",
    "#FF0066": "towel", "#FFAD00": "light;light;source", "#FF0014": "truck;motortruck",
    "#FFB8B8": "tower", "#001FFF": "chandelier;pendant;pendent", "#00FF3D": "awning;sunshade;sunblind",
    "#0047FF": "streetlight;street;lamp", "#FF00CC": "booth;cubicle;stall;kiosk",
    "#00FFC2": "television;television;receiver;television;set;tv;tv;set;idiot;box;boob;tube;telly;goggle;box",
    "#00FF52": "airplane;aeroplane;plane", "#000AFF": "dirt;track",
    "#0070FF": "apparel;wearing;apparel;dress;clothes", "#3300FF": "pole",
    "#00C2FF": "land;ground;soil", "#007AFF": "bannister;banister;balustrade;balusters;handrail",
    "#00FFA3": "escalator;moving;staircase;moving;stairway",
    "#FF9900": "ottoman;pouf;pouffe;puff;hassock", "#00FF0A": "bottle",
    "#FF7000": "buffet;counter;sideboard", "#8FFF00": "poster;posting;placard;notice;bill;card",
    "#5200FF": "stage", "#A3FF00": "van", "#FFEB00": "ship", "#08B8AA": "fountain",
    "#8500FF": "conveyer;belt;conveyor;belt;conveyer;conveyor;transporter", "#00FF5C": "canopy",
    "#B800FF": "washer;automatic;washer;washing;machine", "#FF001F": "plaything;toy",
    "#00B8FF": "swimming;pool;swimming;bath;natatorium", "#00D6FF": "stool", "#FF0070": "barrel;cask",
    "#5CFF00": "basket;handbasket", "#00E0FF": "waterfall;falls", "#70E0FF": "tent;collapsible;shelter",
    "#46B8A0": "bag", "#A300FF": "minibike;motorbike", "#9900FF": "cradle", "#47FF00": "oven",
    "#FF00A3": "ball", "#FFCC00": "food;solid;food", "#FF008F": "step;stair",
    "#00FFEB": "tank;storage;tank", "#85FF00": "trade;name;brand;name;brand;marque",
    "#FF00EB": "microwave;microwave;oven", "#F500FF": "pot;flowerpot",
    "#FF007A": "animal;animate;being;beast;brute;creature;fauna", "#FFF500": "bicycle;bike;wheel;cycle",
    "#0ABED4": "lake", "#D6FF00": "dishwasher;dish;washer;dishwashing;machine",
    "#00CCFF": "screen;silver;screen;projection;screen", "#1400FF": "blanket;cover",
    "#FFFF00": "sculpture", "#0099FF": "hood;exhaust;hood", "#0029FF": "sconce", "#00FFCC": "vase",
    "#2900FF": "traffic;light;traffic;signal;stoplight", "#29FF00": "tray",
    "#AD00FF": "ashcan;trash;can;garbage;can;wastebin;ash;bin;ash-bin;ashbin;dustbin;trash;barrel;trash;bin",
    "#00F5FF": "fan", "#4700FF": "pier;wharf;wharfage;dock", "#7A00FF": "crt;screen",
    "#00FFB8": "plate", "#005CFF": "monitor;monitoring;device", "#B8FF00": "bulletin;board;notice;board",
    "#0085FF": "shower", "#FFD600": "radiator", "#19C2C2": "glass;drinking;glass",
    "#66FF00": "clock", "#5C00FF": "flag",
}

def to_rgb(color_hex: str) -> Tuple[int, int, int]:
    """Converts a hex color string to an RGB tuple."""
    color_hex = color_hex.lstrip('#')
    return tuple(int(color_hex[i:i+2], 16) for i in (0, 2, 4))

def map_colors_rgb(color_rgb_tuple: Tuple[int, int, int]) -> str:
    """Maps an RGB color tuple to a semantic object name."""
    # Initialize COLOR_MAPPING_RGB if not already done (should be done once at module load)
    global COLOR_MAPPING_RGB
    if 'COLOR_MAPPING_RGB' not in globals():
        COLOR_MAPPING_RGB = {to_rgb(k): v for k, v in COLOR_MAPPING_.items()}

    if color_rgb_tuple in COLOR_MAPPING_RGB:
        return COLOR_MAPPING_RGB[color_rgb_tuple]
    else:
        # Fallback to finding the closest color name if exact match not found
        closest_color_name = "unknown"
        min_dist = float('inf')
        for mapped_rgb, name in COLOR_MAPPING_RGB.items():
            dist = np.sum((np.array(color_rgb_tuple) - np.array(mapped_rgb))**2)
            if dist < min_dist:
                min_dist = dist
                closest_color_name = name
        return closest_color_name

# Initialize COLOR_MAPPING_RGB here so it's ready when imported
COLOR_MAPPING_RGB = {to_rgb(k): v for k, v in COLOR_MAPPING_.items()}

def ade_palette() -> List[List[int]]:
    """Returns the ADE20K palette for semantic segmentation visualization."""
    return [[120, 120, 120], [180, 120, 120], [6, 230, 230], [80, 50, 50],
            [4, 200, 3], [120, 120, 80], [140, 140, 140], [204, 5, 255],
            [230, 230, 230], [4, 250, 7], [224, 5, 255], [235, 255, 7],
            [150, 5, 61], [120, 120, 70], [8, 255, 51], [255, 6, 82],
            [143, 255, 140], [204, 255, 4], [255, 51, 7], [204, 70, 3],
            [0, 102, 200], [61, 230, 250], [255, 6, 51], [11, 102, 255],
            [255, 7, 71], [255, 9, 224], [9, 7, 230], [220, 220, 220],
            [255, 9, 92], [112, 9, 255], [8, 255, 214], [7, 255, 224],
            [255, 184, 6], [10, 255, 71], [255, 41, 10], [7, 255, 255],
            [224, 255, 8], [102, 8, 255], [255, 61, 6], [255, 194, 7],
            [255, 122, 8], [0, 255, 20], [255, 8, 41], [255, 5, 153],
            [6, 51, 255], [235, 12, 255], [160, 150, 20], [0, 163, 255],
            [140, 140, 140], [250, 10, 15], [20, 255, 0], [31, 255, 0],
            [255, 31, 0], [255, 224, 0], [153, 255, 0], [0, 0, 255],
            [255, 71, 0], [0, 235, 255], [0, 173, 255], [31, 0, 255],
            [11, 200, 200], [255, 82, 0], [0, 255, 245], [0, 61, 255],
            [0, 255, 112], [0, 255, 133], [255, 0, 0], [255, 163, 0],
            [255, 102, 0], [194, 255, 0], [0, 143, 255], [51, 255, 0],
            [0, 82, 255], [0, 255, 41], [0, 255, 173], [10, 0, 255],
            [173, 255, 0], [0, 255, 153], [255, 92, 0], [255, 0, 255],
            [255, 0, 245], [255, 0, 102], [255, 173, 0], [255, 0, 20],
            [255, 184, 184], [0, 31, 255], [0, 255, 61], [0, 71, 255],
            [255, 0, 204], [0, 255, 194], [0, 255, 82], [0, 10, 255],
            [0, 112, 255], [51, 0, 255], [0, 194, 255], [0, 122, 255],
            [0, 255, 163], [255, 153, 0], [0, 255, 10], [255, 112, 0],
            [143, 255, 0], [82, 0, 255], [163, 255, 0], [255, 235, 0],
            [8, 184, 170], [133, 0, 255], [0, 255, 92], [184, 0, 255],
            [255, 0, 31], [0, 184, 255], [0, 214, 255], [255, 0, 112],
            [92, 255, 0], [0, 224, 255], [112, 224, 255], [70, 184, 160],
            [163, 0, 255], [153, 0, 255], [71, 255, 0], [255, 0, 163],
            [255, 204, 0], [255, 0, 143], [0, 255, 235], [133, 255, 0],
            [255, 0, 235], [245, 0, 255], [255, 0, 122], [255, 245, 0],
            [10, 190, 212], [214, 255, 0], [0, 204, 255], [20, 0, 255],
            [255, 255, 0], [0, 153, 255], [0, 41, 255], [0, 255, 204],
            [41, 0, 255], [41, 255, 0], [173, 0, 255], [0, 245, 255],
            [71, 0, 255], [122, 0, 255], [0, 255, 184], [0, 92, 255],
            [184, 255, 0], [0, 133, 255], [255, 214, 0], [25, 194, 194],
            [102, 255, 0], [92, 0, 255]]

def load_and_preprocess_image(image: Union[Image.Image, np.ndarray]) -> Image.Image:
    """
    Loads an image (PIL or numpy array) and preprocesses it for model input.
    """
    if isinstance(image, np.ndarray):
        if image.shape[-1] == 4: # If RGBA, convert to RGB
            image = Image.fromarray(image).convert('RGB')
        else: # Assume RGB
            image = Image.fromarray(image)
    elif not isinstance(image, Image.Image):
        raise TypeError(f"load_and_preprocess_image received unexpected image type: {type(image)}")

    image = image.convert("RGB")
    image = image.resize((512, 512)) # Standardize size for models
    return image

def get_segmentation_data(image: Image.Image) -> Tuple[np.ndarray, Image.Image, List[str], Dict[Tuple[int, int, int], str]]:
    """
    Performs semantic segmentation on the input image.
    Returns the raw segmentation map (numpy), a colored segmentation image (PIL),
    a list of detected object names, and the segment items map.
    """
    if not isinstance(image, Image.Image):
        raise TypeError("Input 'image' must be a PIL Image object.")

    with torch.inference_mode():
        semantic_inputs = processor(images=image, return_tensors="pt", size={"height": 256, "width": 256})
        semantic_inputs = {key: value.to(DEVICE) for key, value in semantic_inputs.items()}

        semantic_outputs = model(**semantic_inputs)

        if hasattr(semantic_outputs, 'logits') and torch.is_tensor(semantic_outputs.logits):
            semantic_outputs.logits = semantic_outputs.logits.to("cpu")
        if hasattr(semantic_outputs, 'pred_masks') and torch.is_tensor(semantic_outputs.pred_masks):
            semantic_outputs.pred_masks = semantic_outputs.pred_masks.to("cpu")

        segmentation_maps = processor.post_process_semantic_segmentation(semantic_outputs, target_sizes=[image.size[::-1]])
        predicted_semantic_map_np = segmentation_maps[0].cpu().numpy()

    if predicted_semantic_map_np.size == 0:
        print("Warning: Mask2Former detected no objects in the image.")
        color_seg = np.zeros((image.size[1], image.size[0], 3), dtype=np.uint8)
        detected_items = []
        temp_segment_map = {}
    else:
        color_seg = np.zeros((predicted_semantic_map_np.shape[0], predicted_semantic_map_np.shape[1], 3), dtype=np.uint8)
        palette = np.array(ade_palette())
        unique_labels = np.unique(predicted_semantic_map_np)

        detected_items = []
        temp_segment_map = {}

        for label in unique_labels:
            color = palette[label]
            item_name = map_colors_rgb(tuple(color))
            color_seg[predicted_semantic_map_np == label, :] = color
            if item_name not in detected_items:
                detected_items.append(item_name)
            temp_segment_map[tuple(color)] = item_name

    seg_image = Image.fromarray(color_seg).convert('RGB')
    return predicted_semantic_map_np, seg_image, detected_items, temp_segment_map



from skimage import color # For LAB color space manipulation
from PIL import ImageFilter # Import ImageFilter here


def apply_color_change_to_objects(
    original_image: Image.Image,
    segmentation_np: np.ndarray,
    segment_items_map: Dict[Tuple[int, int, int], str],
    selected_object_names: List[str],
    target_hex_color: str
) -> Image.Image:
    """
    Applies a new color to selected objects in the original image, preserving texture and lighting.
    Uses LAB color space for initial color shift and then blends with original luminance.
    Also applies a slight blur to the mask for smoother transitions.
    """
    # Ensure skimage.color is available within the function scope
    import skimage.color
    # Ensure ImageFilter is available within the function scope
    from PIL import ImageFilter


    if not selected_object_names:
        return original_image # No objects selected, return original

    # Convert original image to NumPy array and then to LAB color space
    original_np = np.array(original_image)
    print(f"original_np shape: {original_np.shape}, dtype: {original_np.dtype}")
    original_np_normalized = original_np / 255.0
    print(f"original_np_normalized shape: {original_np_normalized.shape}, dtype: {original_np_normalized.dtype}")
    original_lab = skimage.color.rgb2lab(original_np_normalized) # Normalize to 0-1 for skimage

    print("hexa color to rgb")
    # Convert target hex color to RGB tuple (0-255)
    target_rgb_tuple = to_rgb(target_hex_color)
    print("RGB to LAB")
    # Convert target RGB to LAB color space (normalized for skimage)
    target_lab = skimage.color.rgb2lab(np.array(target_rgb_tuple).reshape(1, 1, 3) / 255.0).flatten()

    # Extract L, a, b channels from target_lab
    target_L, target_a, target_b = target_lab[0], target_lab[1], target_lab[2]

    # Create a mask for all selected objects based on segmentation labels
    # The segmentation_np contains integer labels, not RGB colors directly.
    # We need to map selected object names back to their corresponding integer labels.
    combined_mask_raw = np.zeros(segmentation_np.shape, dtype=bool)

    # Create a reverse mapping from object name to label
    name_to_label = {}
    # Iterate through unique labels present in the segmentation_np
    palette = np.array(ade_palette())
    unique_labels_in_segmentation = np.unique(segmentation_np)


    for label in unique_labels_in_segmentation:
        if label < len(palette): # Ensure label is within palette bounds
            color_rgb_from_palette = tuple(palette[label].tolist())
            item_name = map_colors_rgb(color_rgb_from_palette)
            name_to_label[item_name] = label

    for selected_name in selected_object_names:
        if selected_name in name_to_label:
            label = name_to_label[selected_name]
            # Create mask for the current object's label
            object_mask = (segmentation_np == label)
            combined_mask_raw = np.logical_or(combined_mask_raw, object_mask)

    # Convert raw boolean mask to uint8 for PIL Image and blurring
    combined_mask_pil = Image.fromarray(combined_mask_raw.astype(np.uint8) * 255)

    # Feather the mask for smoother transitions
    # Adjust radius as needed for desired softness
    feathered_mask_pil = combined_mask_pil.filter(ImageFilter.GaussianBlur(radius=5))
    feathered_mask_np = np.array(feathered_mask_pil) / 255.0 # Normalize to 0-1

    # Apply color change to the original LAB image
    modified_lab = original_lab.copy()

    # Create a new LAB image with the target color everywhere
    target_lab_full = np.full(original_lab.shape, target_lab)

    # Blend the original LAB with the target LAB using the feathered mask
    # This blends the color (a, b channels) while trying to retain luminance (L channel)
    # A simple linear interpolation for a and b channels
    modified_lab[:, :, 1] = original_lab[:, :, 1] * (1 - feathered_mask_np) + target_lab_full[:, :, 1] * feathered_mask_np
    modified_lab[:, :, 2] = original_lab[:, :, 2] * (1 - feathered_mask_np) + target_lab_full[:, :, 2] * feathered_mask_np

    # For luminance (L channel), we'll keep the original luminance to preserve texture.
    # We are not blending L channel here, as it often leads to a "flatter" look.
    # modified_lab[:, :, 0] = original_lab[:, :, 0] * (1 - feathered_mask_np) + target_lab_full[:, :, 0] * feathered_mask_np


    # Convert back to RGB and then to PIL Image
    modified_rgb_normalized = skimage.color.lab2rgb(modified_lab)
    modified_rgb_255 = (modified_rgb_normalized * 255).astype(np.uint8)

    # Post-processing: Apply saturation boost to the masked area
    # Convert the modified image to HSV for saturation adjustment
    modified_hsv = skimage.color.rgb2hsv(modified_rgb_normalized)

    # Define a saturation boost factor (e.g., 1.3 for 30% boost). Experiment with this value.
    # A higher value will result in more intense colors.
    saturation_boost_factor = 1.3

    # Boost saturation only in the masked areas, gradually applying the boost based on the feathered mask
    # modified_hsv[:, :, 1] is the saturation channel
    modified_hsv[:, :, 1] = np.clip(
        modified_hsv[:, :, 1] * (1 + feathered_mask_np * (saturation_boost_factor - 1)),
        0, 1
    )

    # Convert back to RGB
    final_rgb_normalized = skimage.color.hsv2rgb(modified_hsv)
    final_rgb_255 = (final_rgb_normalized * 255).astype(np.uint8)

    return Image.fromarray(final_rgb_255)

import gradio as gr
from PIL import Image
from typing import List, Tuple, Dict, Union
import numpy as np

# --- Global State for this specific app ---
_current_input_image_pil: Union[Image.Image, None] = None
_current_segmentation_np: Union[np.ndarray, None] = None
_current_segment_items_map: Dict[Tuple[int, int, int], str] = {}
_current_detected_objects: List[str] = [] # Stores human-readable names of detected objects

def on_upload_image(input_image_upload: Image.Image) -> Tuple[gr.Image, gr.CheckboxGroup, gr.ColorPicker, gr.Button]:
    """
    Handles the initial image upload, processes it for segmentation,
    and populates the object selection dropdown.
    """
    global _current_input_image_pil, _current_segmentation_np, _current_segment_items_map, _current_detected_objects

    if input_image_upload is None:
        return (
            gr.update(value=None),
            gr.update(choices=[], value=[], interactive=False),
            gr.update(interactive=False),
            gr.update(interactive=False)
        )

    try:
        _current_input_image_pil = load_and_preprocess_image(input_image_upload)

        # Perform semantic segmentation
        segmentation_np, _, detected_objects, segment_items_map = get_segmentation_data(_current_input_image_pil)

        _current_segmentation_np = segmentation_np
        _current_segment_items_map = segment_items_map
        _current_detected_objects = sorted(list(set(detected_objects))) # Store unique sorted names

        # Prepare choices for CheckboxGroup: (value, label) pairs.
        # The 'value' will be the object name (string), and 'label' will also be the object name.
        formatted_choices = [(name, name) for name in _current_detected_objects]

        return (
            gr.update(value=_current_input_image_pil),
            gr.update(choices=formatted_choices, value=[], interactive=True), # No default selection
            gr.update(value="#FF0000", interactive=True), # Default to red
            gr.update(interactive=True)
        )
    except Exception as e:
        print(f"Error during image processing: {e}")
        gr.Warning(f"Failed to process image: {e}")
        return (
            gr.update(value=None),
            gr.update(choices=[], value=[], interactive=False),
            gr.update(interactive=False),
            gr.update(interactive=False)
        )

def handle_apply_color_change(
    selected_object_names: List[str], # This will be a list of strings (object names)
    target_color_hex: str # This will be the hex string from the color picker
) -> gr.Image:
    """
    Applies the chosen color to the selected objects in the image.
    """
    global _current_input_image_pil, _current_segmentation_np, _current_segment_items_map

    if _current_input_image_pil is None:
        gr.Error("Please upload an image first.")
        return None
    if not selected_object_names:
        gr.Warning("Please select at least one object to change its color.")
        return _current_input_image_pil # Return original if no selection
    if not target_color_hex:
        gr.Error("Please select a target color.")
        return None

    print(f"Target color received: {target_color_hex}") # Debugging print statement

    # Convert RGBA string from Gradio ColorPicker to hex string if necessary
    if target_color_hex.startswith('rgba'):
        try:
            # Extract RGBA values
            rgba_values = target_color_hex.replace('rgba(', '').replace(')', '').split(',')
            r, g, b, a = [float(val.strip()) for val in rgba_values]

            # Convert to hex
            # Note: Alpha is ignored for hex conversion as hex does not support alpha
            target_hex_color = '#{:02x}{:02x}{:02x}'.format(int(r), int(g), int(b))
            print(f"Converted to hex: {target_hex_color}") # Debugging print statement
        except Exception as e:
            gr.Error(f"Failed to parse color string: {target_color_hex}. Error: {e}")
            return None
    else:
        target_hex_color = target_color_hex

    print("applu color change strat")
    try:
        output_image = apply_color_change_to_objects(
            original_image=_current_input_image_pil,
            segmentation_np=_current_segmentation_np,
            segment_items_map=_current_segment_items_map,
            selected_object_names=selected_object_names,
            target_hex_color=target_hex_color
        )
        print("applu color change end")
        return output_image
    except Exception as e:
        print(f"Error applying color change: {e}")
        gr.Error(f"Error applying color change: {e}")
        return None

def move_output_to_input_for_ui(output_image_to_move: Image.Image) -> gr.Image:
    """
    Copies the output image back to the input image component for further editing.
    """
    global _current_input_image_pil, _current_segmentation_np, _current_segment_items_map, _current_detected_objects
    if output_image_to_move is None:
        gr.Warning("No output image to move.")
        return gr.update()

    _current_input_image_pil = load_and_preprocess_image(output_image_to_move)

    # Re-segment the new input image to update detected objects
    segmentation_np, _, detected_objects, segment_items_map = get_segmentation_data(_current_input_image_pil)
    _current_segmentation_np = segmentation_np
    _current_segment_items_map = segment_items_map
    _current_detected_objects = sorted(list(set(detected_objects)))

    formatted_choices = [(name, name) for name in _current_detected_objects]

    return gr.update(value=_current_input_image_pil), gr.update(choices=formatted_choices, value=[], interactive=True)

with gr.Blocks() as demo:

    gr.Markdown(
        """
        # Interior Design AI: Object Color Changer
        Upload an image, select objects, and apply a new color while preserving texture.
        """
    )

    with gr.Row():
        with gr.Column():
            input_image_component = gr.Image(
                type="pil",
                label="Upload an image of your room (PNG/JPG)",
                sources=["upload"],
                height=300,
                interactive=True
            )

            gr.Markdown("---")
            gr.Markdown("### Select Objects to Re-color")
            object_selection_checkboxes = gr.CheckboxGroup(
                label="Choose objects to change color",
                choices=[], # Populated after image upload
                interactive=False
            )

            gr.Markdown("---")
            gr.Markdown("### Choose New Color")
            color_picker = gr.ColorPicker(
                label="Select New Color",
                value="#FF0000", # Default to red
                interactive=False
            )

            apply_color_button = gr.Button("üé® Apply Color Change", interactive=False)

        with gr.Column():
            output_image_display = gr.Image(type="pil", label="Resulting Image", height=400)
            move_to_input_btn = gr.Button("üîÅ Use Result as New Input", interactive=False)

    # --- Event Listeners ---

    input_image_component.upload(
        fn=on_upload_image,
        inputs=[input_image_component],
        outputs=[
            input_image_component,
            object_selection_checkboxes,
            color_picker,
            apply_color_button
        ]
    )

    apply_color_button.click(
        fn=handle_apply_color_change,
        inputs=[
            object_selection_checkboxes,
            color_picker
        ],
        outputs=[output_image_display]
    )

    move_to_input_btn.click(
        fn=move_output_to_input_for_ui,
        inputs=[output_image_display],
        outputs=[input_image_component, object_selection_checkboxes] # Update checkboxes too
    )

# To run this app: uncomment the line below and run the file (e.g., python app_color_changer.py)
demo.launch(debug=True)

